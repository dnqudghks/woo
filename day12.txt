day12

객체지향 언어의 특징

	1. 상속
	2. 다형성
	3. 은닉화/캡슐화
		==> 중요한 데이터를 기억하는 변수는 감춰놓고
			변수를 셋팅하거나 사용할 때는
			함수를 통해서 사용하도록 하는 기법
			
---------------------------------------------------------

함수의 오버로딩(Over Loading : 함수의 중첩)
==> 원칙적으로 같은 클래스 안에서는 함수의 이름은 모두 달라야한다.
	혹시나 같은 이름의 함수가 같은 클래스 내에 존재한다면 에러가 발생한다.
	
	이렇게 함수를 만들다 보면 
		==> 함수의 이름을 만들기가 힘들어 진다.
			가독성에 문제가 발생할 수 있다.
			여기서 가독성이란
			함수의 이름만 봐도 그 함수가 어떤 기능을 가진 함수인지를 알아야하는데
			함수의 이름을 모두 다르게 만들다 보면 가독성에서
			문제가 발생할 수 있다.
			
			따라서 이 문제를 해결하기 위해서 도입된 문법이
				"함수의 오버로딩"
			이다.
			
			오버로딩이란?
			같은 클래스안에 같은 이름의 함수를 만들 수 있다.
			단, 다음 조건은 반드시 지켜야 한다.
			
			******************
			0. 중첩해서 만들려는 함수가 존재해야 한다.
			1. 함수의 이름을 동일하게 만든다. 
			2. 함수의 매개변수리스트의 형태가 달라야한다.
				여기서 형태는 매개변수의 갯수, 순서, 형태 중 하나 이상이 달라야한다.
				
				예 ]
					abc(int a, int b){} --- x
					
					abc(int b, int a){} --- x
					
					abc(int a) ------------ o 
					abc(float a) ---------- o
					abc() ----------------- o
					
					참고 ] 매개변수의 이름은 중요하지않다.
					
				3. 반환값과는 전혀 상관이 없다.
			
	결론 ]
		함수를 호출할 때 정확한 함수를 선택할 수 있도록 해야한다.
		==> 원래의 함수의 오버로딩 규칙
		
		예 ]
			void abc(){}		----- 1)
			int abc(int a){} 	----- 2)
			
			abc();			==> 1) 이 실행
			abc(10);		==> 2) 이 실행
			abc('a');		==> 2) 이 실행 < == 문자가 정수로 자동 형변환 되기 때문에 가능
	
			void xyz(int a, float b) 	-- 1)
			void xyz(float a, int b)	-- 2)
			
			xyz(2, 3.14f);	==> 1) 이 실행
			xyz(3.14f, 20);	==> 2) 이 실행
사용법 ]
==> 다른 사람들이 만든 클래스에도 오버로딩이 구현된 함수들이 존재한다.
	이들 함수를 사용하는 방법은
	원하는 기능을 하는 함수가 요구하는 데이터를 
	형태와 순서에 맞춰서 정확하게 입력해주면 된다.
	
	참고 ]
		형태가 맞지 않더라도 실행되는 경우가 있는데
		이 경우는 자동 형변환이 되는 경우이다.
		
		예 ]
			
			void abc(double a){}
			
			abc(3.14);	--> 실행된다
			abc(3.14f); --> 실행된다	자동형변환이 되기 때문에
			abc(100);	--> 실행된다	자동형변환이 되기 때문에
------------------------------------------------------------------------
# println(), print(), printf() 를 사용해서
	자동적으로 객체가 가지고 있는 toString() 함수를 호출해서 출력하게 된다.

-----------------------------------------------------------------------

가변인자
==> 우리가 함수를 제작할 때
	그 함수가 가지고 있는 매개변수와 동일한 갯수, 형태, 순서를 이용해서 함수를 호출해야만 한다.
	
	void abc(int a){}
	==>
	abc(5);
	
	void abc(int a, int b){}
	==> abc(5, 2);
	
	만약 함수를 호출하려고 하는데
	호출 할 때마다 같은 타입의 데이터의 갯수가 변경이 되는 경우는 ???
	==> 이런 경우 사용할 수 있는 개념의 매개변수가 가변 인수이다.
	==> 데이터의 갯수에 상관없이
		모든 데이터를 다 받을 수 있도록 하는 것.
		==> 준비된 데이터의 갯수가 달라지더라도 사용할 수 있는 함수를 정의 할 수 있게 된다.
		
	형식 ]
		
		[접근지정자]	[속성] 반환값 타입   함수이름(데이터 타입 ... 변수이름){}
		
		예 ]
			void abc(int ... no){
				==> 이렇게 함수를 정의를 하면
					이 함수는 데이터의 갯수에 관계없이
					정의된 타입의 데이터를 입력받을 수 있게 된다.
			}
			
			==> 사용
			
				abc(1);
				abc(2,3);
				abc(1,2,3,4,5,6,7,8,9);
		***
		주의 ]
			가변인수 변수는 자동 배열 변수가 된다.
			따라서 배열 변수처럼 사용해야 된다.
			
		주의 ]
			가변인수 앞에는 다른 매개변수가 와도 상관이 없다.
			가변인수 뒤에는 다른 매개변수가 오면 안된다.
			
			예 ]
				void abc(String str, int ... no){} ---- o
				
				void abc(int ... no, String str){} ---- x




























